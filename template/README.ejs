<% 
const fs = require('fs');
const path = require('path');

// æ–‡ä»¶å­˜å‚¨è·¯å¾„
const outputDir = '/';
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir);
}

// å­˜å‚¨ README å†…å®¹
let readmeContent = `ðŸ¤© æˆ‘çš„staråˆ—è¡¨ï¼Œ0,8,16è‡ªåŠ¨æ›´æ–° ðŸ¤©
<br>

## Table of Contents\n`;

// å°†æ‰€æœ‰ä»“åº“æŒ‰è¯­è¨€å­˜å‚¨åˆ°ä¸€ä¸ªæ•°ç»„ä¸­
const languageEntries = Array.from(stars);
const languageRepositories = new Map();

// åˆå§‹åŒ–è¯­è¨€å’Œä»“åº“æ•°æ®
languageEntries.forEach(([language, repositories]) => {
  const sortedRepositories = repositories.slice().sort((a, b) => b.stargazers_count - a.stargazers_count);
  languageRepositories.set(language, sortedRepositories);
});

// éåŽ†æ¯ç§è¯­è¨€å¹¶ç”Ÿæˆæ–‡ä»¶å’Œ README å†…å®¹
languageRepositories.forEach((repositories, language) => {
  // ç”Ÿæˆè¯­è¨€æ–‡ä»¶
  const fileName = `${language.replace(/\s+/g, '-').toLowerCase()}.md`;
  const filePath = path.join(outputDir, fileName);
  const fileContent = [
    `## ${language}`,
    ...repositories.map(repo => `- [${repo.full_name}](${repo.html_url}) - ${repo.description || ''}`)
  ].join('\n');

  fs.writeFileSync(filePath, fileContent, 'utf8');

  // æ›´æ–° README å†…å®¹
  readmeContent += `- [${language}](docs/${fileName})\n`;
});

// å†™å…¥ README.md æ–‡ä»¶
fs.writeFileSync('README.md', readmeContent, 'utf8');
%>
